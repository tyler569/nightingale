#!/usr/bin/env ruby

require 'optparse'
require_relative '../lib/package_manager'

class CLI
  def initialize
    @options = {}
    @package_manager = PackageManager.new
  end

  def run(args)
    parser = create_option_parser

    begin
      parser.parse!(args)
    rescue OptionParser::InvalidOption => e
      puts "Error: #{e.message}"
      puts parser
      exit 1
    end

    command = args.shift

    case command
    when 'build'
      if args.empty?
        build_all
      else
        build_package(args.first)
      end
    when 'list'
      list_packages
    when 'clean'
      clean_build
    when 'help', nil
      puts parser
    else
      puts "Unknown command: #{command}"
      puts parser
      exit 1
    end
  end

  private

  def create_option_parser
    OptionParser.new do |opts|
      opts.banner = "Usage: pkgmgr [options] COMMAND [args]"
      opts.separator ""
      opts.separator "Commands:"
      opts.separator "    build [PACKAGE]    Build specified package or all packages"
      opts.separator "    list               List all available packages"
      opts.separator "    clean              Clean build directories"
      opts.separator "    help               Show this help message"
      opts.separator ""
      opts.separator "Options:"

      opts.on("-h", "--help", "Show this help message") do
        puts opts
        exit
      end

      opts.on("--sysroot PATH", "Set sysroot path") do |path|
        ENV['SYSROOT'] = path
      end

      opts.on("--build-dir PATH", "Set build directory path") do |path|
        ENV['BUILD_DIR'] = path
      end
    end
  end

  def build_package(package_name)
    puts "Building package: #{package_name}"

    begin
      @package_manager.build_package(package_name)
      puts "Build completed successfully"
    rescue => e
      puts "Build failed: #{e.message}"
      exit 1
    end
  end

  def build_all
    puts "Building all packages..."

    begin
      @package_manager.build_all
      puts "All packages built successfully"
    rescue => e
      puts "Build failed: #{e.message}"
      exit 1
    end
  end

  def list_packages
    packages = @package_manager.load_packages

    if packages.empty?
      puts "No packages found"
      return
    end

    puts "Available packages:"
    packages.each do |package|
      deps = package.dependencies.empty? ? "none" : package.dependencies.join(", ")
      puts "  #{package.name} v#{package.version} (dependencies: #{deps})"
    end
  end

  def clean_build
    build_dir = ENV['BUILD_DIR'] || 'build'

    if File.exist?(build_dir)
      puts "Cleaning build directory: #{build_dir}"
      FileUtils.rm_rf(build_dir)
      puts "Build directory cleaned"
    else
      puts "Build directory does not exist: #{build_dir}"
    end
  end
end

if __FILE__ == $0
  CLI.new.run(ARGV)
end